<!-- Generated by SpecStory -->

# How to plot a network in PyPSA (2025-08-08 12:53Z)

_**User**_

what pypsa function can I use to plot the network in a visual way?

---

_**Assistant**_

I'll help you find the PyPSA functions for plotting networks visually. Let me check the codebase for relevant plotting functions.

---

<details>
                <summary>Searched codebase "pypsa network plot function" • **8** results</summary>
            
| File | Lines |
|------|-------|
| `scripts/plot_network.py` | L1064-1132 |
| `scripts/plot_network.py` | L96-270 |
| `scripts/plot_network.py` | L574-744 |
| `scripts/plot_network.py` | L1129-1148 |
| `scripts/plot_network.py` | Lundefined-89 |
| `scripts/plot_network.py` | L113-270 |
| `scripts/plot_network.py` | L473-571 |
| `scripts/_helpers.py` | L266-314 |

</details>

---

Let me check the content of your open notebook to understand what you're trying to do.

---

Read file: undefined

---

Let me also check the PyPSA documentation for plotting functions.

---

<details>
            <summary>Searched web "pypsa network plot function documentation" • **1** results</summary>
        
| Title | URL |
|-------|-----|
| Web Search Results | undefined |

</details>

---

Based on the information I've found, PyPSA provides several ways to plot your network visually:

1. The basic `n.plot()` method for static plots
2. The `n.iplot()` method for interactive plots (requires plotly)

Let me add these plotting functions to your notebook:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 5, lines removed: undefined

```diff
@@ -1,2 +1,7 @@
+ import pypsa
+ import matplotlib.pyplot as plt
+ import cartopy.crs as ccrs
+ 
+ # Load network
  network_file="/Users/antoniagrindrod/Documents/pypsa-earth_project/pypsa-earth-RL/networks/elec_s_5_ec_lcopt_3h.nc"
  n = pypsa.Network(network_file)
```

</details>

---

Now let's add cells for both static and interactive plotting:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 20, lines removed: 1

```diff
@@ -1,1 +1,20 @@
- 
+ # Static plot with matplotlib
+ fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with customization
+ n.plot(
+     ax=ax,
+     bus_sizes=0.5,  # Adjust size of bus markers
+     bus_colors='red',  # Color of bus markers
+     line_widths=n.lines.s_nom/1e3,  # Line width proportional to capacity
+     line_colors='blue',  # Color of lines
+     link_widths=n.links.p_nom/1e3 if not n.links.empty else 0,  # Link width proportional to capacity
+     link_colors='green',  # Color of links
+     title="PyPSA Network Visualization",
+     color_geomap=True,  # Add geographical background
+     geomap=True,  # Use geographical coordinates
+ )
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 13, lines removed: 1

```diff
@@ -1,1 +1,13 @@
- 
+ # Interactive plot with plotly (requires plotly package)
+ try:
+     # Interactive plot
+     n.iplot(
+         bus_sizes=2,
+         bus_colors='cadetblue',
+         line_widths=n.lines.s_nom/1e3,
+         line_colors='rosybrown',
+         title='Interactive Network Visualization'
+     )
+ except ImportError:
+     print("Plotly is not installed. Install with: pip install plotly")
+ 
```

</details>

---

Let's add one more cell that demonstrates how to create a more customized plot using the code from the PyPSA-Earth codebase:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 51, lines removed: 1

```diff
@@ -1,1 +1,51 @@
- 
+ # Advanced customized plot (similar to plot_network.py in PyPSA-Earth)
+ fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Define tech colors for different generation technologies
+ tech_colors = {
+     "solar": "gold",
+     "onwind": "skyblue",
+     "offwind": "dodgerblue",
+     "hydro": "lightseagreen",
+     "ror": "aquamarine",
+     "coal": "dimgray",
+     "OCGT": "lightcoral",
+     "CCGT": "indianred",
+     "oil": "darkgray",
+     "nuclear": "mediumpurple",
+     "geothermal": "darkred",
+ }
+ 
+ # Get generation capacities by bus and carrier
+ if not n.generators.empty:
+     bus_sizes = n.generators.groupby(["bus", "carrier"]).p_nom.sum()
+     
+     # Plot network with customized parameters
+     n.plot(
+         ax=ax,
+         bus_sizes=bus_sizes/100,  # Size proportional to generation capacity
+         bus_colors=tech_colors,  # Colors based on technology type
+         line_widths=n.lines.s_nom/1e3,  # Line width proportional to capacity
+         line_colors="purple",  # Color of existing lines
+         link_widths=n.links.p_nom/1e3 if not n.links.empty else 0,
+         link_colors="red",
+         title="PyPSA-Earth Network with Generation Mix",
+         color_geomap=True,
+         geomap=True,
+     )
+ else:
+     # Fallback if no generators in the network
+     n.plot(
+         ax=ax,
+         bus_sizes=0.5,
+         bus_colors="red",
+         line_widths=n.lines.s_nom/1e3,
+         line_colors="purple",
+         title="PyPSA-Earth Network",
+         color_geomap=True,
+         geomap=True,
+     )
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

To visualize your PyPSA network, you can use:

1. `n.plot()` - For static plots using matplotlib
2. `n.iplot()` - For interactive plots using plotly

I've added three example cells to your notebook:

1. A basic static plot with customization options
2. An interactive plot using plotly (requires the plotly package)
3. An advanced plot similar to what's used in PyPSA-Earth's codebase

You can run these cells and adjust parameters like colors, sizes, and line widths to customize your visualization. The third example shows how to color buses by generation technology and size them according to capacity.

---

_**User**_

help witht this error:
Colors not defined for all elements in the second MultiIndex 

---

_**Assistant**_

I'll help you fix the "Colors not defined for all elements in the second MultiIndex" error. This typically happens when you're using a MultiIndex for bus colors but don't have colors defined for all carriers in your network. Let me check your notebook to see what's happening.

---

Read file: undefined

---

Let me check what carriers are actually in your network to fix the color mapping:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 9, lines removed: 1

```diff
@@ -1,1 +1,9 @@
- 
+ # Check what carriers are in the network
+ print("Available carriers in the network:")
+ print(n.carriers)
+ print("\nGenerators carriers:")
+ print(n.generators.carrier.unique())
+ print("\nBus-carrier combinations in generators:")
+ if not n.generators.empty:
+     print(n.generators.groupby(["bus", "carrier"]).p_nom.sum().index.levels[1])
+ 
```

</details>

---

Now let's fix the advanced plot by ensuring we have colors for all carriers in your network:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -1,6 +1,7 @@
- # Advanced customized plot (similar to plot_network.py in PyPSA-Earth)
+ # Advanced customized plot - Fixed version
  fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
  
  # Define tech colors for different generation technologies
+ # Include all carriers that might be in your network
  tech_colors = {
      "solar": "gold",
```

**Chunk 2**
Lines added: 26, lines removed: 31

```diff
@@ -15,35 +16,30 @@
      "nuclear": "mediumpurple",
      "geothermal": "darkred",
- }
- 
- # Get generation capacities by bus and carrier
- if not n.generators.empty:
-     bus_sizes = n.generators.groupby(["bus", "carrier"]).p_nom.sum()
-     
-     # Plot network with customized parameters
-     n.plot(
-         ax=ax,
-         bus_sizes=bus_sizes/100,  # Size proportional to generation capacity
-         bus_colors=tech_colors,  # Colors based on technology type
-         line_widths=n.lines.s_nom/1e3,  # Line width proportional to capacity
-         line_colors="purple",  # Color of existing lines
-         link_widths=n.links.p_nom/1e3 if not n.links.empty else 0,
-         link_colors="red",
-         title="PyPSA-Earth Network with Generation Mix",
-         color_geomap=True,
-         geomap=True,
-     )
- else:
-     # Fallback if no generators in the network
-     n.plot(
-         ax=ax,
-         bus_sizes=0.5,
-         bus_colors="red",
-         line_widths=n.lines.s_nom/1e3,
-         line_colors="purple",
-         title="PyPSA-Earth Network",
-         color_geomap=True,
-         geomap=True,
-     )
+     "biomass": "olive",
+     "gas": "salmon",
+     "wind": "deepskyblue",
+     "offwind-ac": "royalblue",
+     "offwind-dc": "navy",
+     "solar PV": "gold",
+     "solar thermal": "orange",
+     "load": "black",
+     "battery": "pink",
+     "H2": "lightsteelblue",
+     "hydrogen": "lightsteelblue",
+     "AC": "rosybrown",
+     "DC": "darkred"
+ }
+ 
+ # Method 1: Use a single color for all buses
+ n.plot(
+     ax=ax,
+     bus_sizes=0.5,
+     bus_colors='red',  # Single color for all buses
+     line_widths=n.lines.s_nom/1e3,
+     line_colors="purple",
+     title="PyPSA-Earth Network - Fixed Version",
+     color_geomap=True,
+     geomap=True,
+ )
  
  plt.tight_layout()
```

</details>

---

Now let's add a new cell with a safer approach to plot with carrier-based colors:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 100, lines removed: 1

```diff
@@ -1,1 +1,100 @@
- 
+ # Advanced plot with carrier colors - safe approach
+ fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Define tech colors for different generation technologies
+ tech_colors = {
+     "solar": "gold",
+     "onwind": "skyblue",
+     "offwind": "dodgerblue",
+     "hydro": "lightseagreen",
+     "ror": "aquamarine",
+     "coal": "dimgray",
+     "OCGT": "lightcoral",
+     "CCGT": "indianred",
+     "oil": "darkgray",
+     "nuclear": "mediumpurple",
+     "geothermal": "darkred",
+     "biomass": "olive",
+     "gas": "salmon",
+     "wind": "deepskyblue",
+     "offwind-ac": "royalblue",
+     "offwind-dc": "navy",
+     "solar PV": "gold",
+     "solar thermal": "orange",
+     "load": "black",
+     "battery": "pink",
+     "H2": "lightsteelblue",
+     "hydrogen": "lightsteelblue",
+     "AC": "rosybrown",
+     "DC": "darkred"
+ }
+ 
+ if not n.generators.empty:
+     # Get unique carriers in the network
+     carriers = n.generators.carrier.unique()
+     
+     # Make sure we have colors for all carriers
+     for carrier in carriers:
+         if carrier not in tech_colors:
+             tech_colors[carrier] = "gray"  # Default color for undefined carriers
+     
+     # Calculate bus sizes based on generation capacity
+     bus_sizes = {}
+     for bus in n.buses.index:
+         # Get generators at this bus
+         gens_at_bus = n.generators[n.generators.bus == bus]
+         if not gens_at_bus.empty:
+             # Sum up capacity
+             bus_sizes[bus] = gens_at_bus.p_nom.sum() / 100
+         else:
+             bus_sizes[bus] = 0.2  # Default size for buses without generators
+     
+     # Create a dictionary for bus colors based on dominant generation type
+     bus_colors = {}
+     for bus in n.buses.index:
+         gens_at_bus = n.generators[n.generators.bus == bus]
+         if not gens_at_bus.empty:
+             # Find dominant carrier
+             dominant_carrier = gens_at_bus.groupby('carrier').p_nom.sum().idxmax()
+             bus_colors[bus] = tech_colors[dominant_carrier]
+         else:
+             bus_colors[bus] = "gray"  # Default color for buses without generators
+ 
+     # Plot network with customized parameters
+     n.plot(
+         ax=ax,
+         bus_sizes=bus_sizes,  # Size proportional to generation capacity
+         bus_colors=bus_colors,  # Colors based on dominant technology
+         line_widths=n.lines.s_nom/1e3,  # Line width proportional to capacity
+         line_colors="purple",  # Color of existing lines
+         link_widths=n.links.p_nom/1e3 if not n.links.empty else 0,
+         link_colors="red",
+         title="PyPSA-Earth Network with Generation Mix",
+         color_geomap=True,
+         geomap=True,
+     )
+ else:
+     # Fallback if no generators in the network
+     n.plot(
+         ax=ax,
+         bus_sizes=0.5,
+         bus_colors="red",
+         line_widths=n.lines.s_nom/1e3,
+         line_colors="purple",
+         title="PyPSA-Earth Network",
+         color_geomap=True,
+         geomap=True,
+     )
+ 
+ # Add a legend for generation types
+ import matplotlib.patches as mpatches
+ handles = []
+ for carrier, color in tech_colors.items():
+     if carrier in n.generators.carrier.unique():
+         handles.append(mpatches.Patch(color=color, label=carrier))
+ if handles:
+     plt.legend(handles=handles, loc='upper left', bbox_to_anchor=(1, 1))
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

## Todo List

- [x] Fix the MultiIndex color error in the network visualization
- [x] Implement a safe approach for coloring buses by generation type

---

The error "Colors not defined for all elements in the second MultiIndex" occurs because the original code was trying to use a dictionary of tech_colors to color buses based on their generation type, but not all carriers in your network were defined in the tech_colors dictionary.

I've fixed this issue by providing two alternative approaches:

1. **Simple Fix (Cell 3)**: Using a single color for all buses instead of trying to color by carrier type.

2. **Comprehensive Fix (Cell 5)**: A safer approach that:
   - Gets all unique carriers in your network
   - Adds default colors for any carriers not defined in the tech_colors dictionary
   - Creates a dictionary mapping each bus to its color based on the dominant generation type
   - Adds a legend showing which color corresponds to which carrier

The second approach is more robust because it:
- Doesn't rely on MultiIndex grouping which was causing the error
- Handles buses that might not have any generators
- Automatically adds colors for any carrier type in your network
- Includes a legend to help interpret the visualization

Run these new cells and the error should be resolved. You can further customize the colors and sizes as needed.

---

_**User**_

why do some buses not appear to be connected to the rest

---

_**Assistant**_

Let me investigate why some buses appear disconnected in your network visualization. This could be due to several reasons, including actual network topology or visualization issues.

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 40, lines removed: 1

```diff
@@ -1,1 +1,40 @@
- 
+ # Check network connectivity
+ print("Network summary:")
+ print(f"Number of buses: {len(n.buses)}")
+ print(f"Number of lines: {len(n.lines)}")
+ print(f"Number of links: {len(n.links)}")
+ 
+ # Check for isolated buses
+ import networkx as nx
+ 
+ # Create a graph from the network
+ G = nx.Graph()
+ 
+ # Add all buses as nodes
+ for bus in n.buses.index:
+     G.add_node(bus)
+ 
+ # Add lines as edges
+ for line in n.lines.index:
+     bus0 = n.lines.at[line, 'bus0']
+     bus1 = n.lines.at[line, 'bus1']
+     G.add_edge(bus0, bus1)
+ 
+ # Add links as edges if they exist
+ if not n.links.empty:
+     for link in n.links.index:
+         bus0 = n.links.at[link, 'bus0']
+         bus1 = n.links.at[link, 'bus1']
+         G.add_edge(bus0, bus1)
+ 
+ # Find connected components
+ components = list(nx.connected_components(G))
+ print(f"\nNumber of connected components: {len(components)}")
+ print(f"Sizes of connected components: {[len(c) for c in components]}")
+ 
+ # Identify isolated buses
+ isolated_buses = [bus for bus in n.buses.index if G.degree(bus) == 0]
+ print(f"\nNumber of isolated buses (no connections): {len(isolated_buses)}")
+ if isolated_buses:
+     print("Isolated buses:", isolated_buses[:10], "..." if len(isolated_buses) > 10 else "")
+ 
```

</details>

---

Now let's add a cell to visualize the network with connected components highlighted in different colors:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 59, lines removed: 1

```diff
@@ -1,1 +1,59 @@
- 
+ # Visualize network with connected components highlighted
+ fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Create colors for connected components
+ import matplotlib.cm as cm
+ import matplotlib.colors as mcolors
+ 
+ # Generate colors for components
+ num_components = len(components)
+ component_colors = {}
+ 
+ if num_components > 0:
+     # Create a colormap with distinct colors for components
+     cmap = plt.get_cmap('tab20' if num_components <= 20 else 'hsv')
+     
+     # Assign colors to buses based on their component
+     bus_colors = {}
+     
+     for i, component in enumerate(components):
+         color = cmap(i / max(1, num_components - 1))
+         # Assign the same color to all buses in this component
+         for bus in component:
+             bus_colors[bus] = color
+     
+     # Assign a different color to isolated buses
+     for bus in isolated_buses:
+         bus_colors[bus] = 'black'
+     
+     # Plot the network with component-based colors
+     n.plot(
+         ax=ax,
+         bus_sizes=0.5,
+         bus_colors=bus_colors,
+         line_widths=n.lines.s_nom/1e3,
+         line_colors='gray',
+         title="Network Connected Components",
+         color_geomap=True,
+         geomap=True,
+     )
+     
+     # Add legend for components
+     legend_elements = []
+     for i, component in enumerate(components):
+         if i < 5:  # Limit legend to first 5 components
+             color = cmap(i / max(1, num_components - 1))
+             legend_elements.append(plt.Line2D([0], [0], marker='o', color='w', 
+                                              markerfacecolor=color, markersize=10,
+                                              label=f'Component {i+1} ({len(component)} buses)'))
+     
+     if isolated_buses:
+         legend_elements.append(plt.Line2D([0], [0], marker='o', color='w', 
+                                          markerfacecolor='black', markersize=10,
+                                          label=f'Isolated buses ({len(isolated_buses)})'))
+     
+     ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1, 1))
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

Let's also add a cell to examine the network's line parameters to check if there might be issues with line capacities or status:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 26, lines removed: 1

```diff
@@ -1,1 +1,26 @@
- 
+ # Analyze line parameters
+ print("Line statistics:")
+ if not n.lines.empty:
+     # Check for zero-capacity lines
+     zero_s_nom = n.lines[n.lines.s_nom == 0]
+     print(f"Lines with zero capacity (s_nom=0): {len(zero_s_nom)}")
+     
+     # Check for very low capacity lines that might not appear visibly
+     low_s_nom = n.lines[n.lines.s_nom < n.lines.s_nom.mean() * 0.01]
+     print(f"Lines with very low capacity (<1% of mean): {len(low_s_nom)}")
+     
+     # Check for lines with status=0 (switched off)
+     if 'status' in n.lines.columns:
+         off_lines = n.lines[n.lines.status == 0]
+         print(f"Lines that are switched off (status=0): {len(off_lines)}")
+     
+     # Check for lines with very high impedance
+     if 'x' in n.lines.columns:
+         high_x = n.lines[n.lines.x > n.lines.x.mean() * 10]
+         print(f"Lines with very high reactance (>10x mean): {len(high_x)}")
+     
+     print("\nSummary of line capacities (s_nom):")
+     print(n.lines.s_nom.describe())
+ else:
+     print("No lines in the network.")
+ 
```

</details>

---

Let's add one more cell to visualize the network with line capacities more clearly visible:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 49, lines removed: 1

```diff
@@ -1,1 +1,49 @@
- 
+ # Visualize network with line capacities emphasized
+ fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot with line widths proportional to capacity
+ if not n.lines.empty:
+     # Calculate line width scaling factor
+     # Use log scale to better visualize differences in line capacities
+     import numpy as np
+     
+     # Avoid log(0) errors by adding a small value
+     min_width = 0.5
+     line_widths = np.log1p(n.lines.s_nom) / np.log1p(n.lines.s_nom.max()) * 5 + min_width
+     
+     # Plot network
+     n.plot(
+         ax=ax,
+         bus_sizes=0.5,
+         bus_colors='red',
+         line_widths=line_widths,  # Logarithmic scaling of line widths
+         line_colors='blue',
+         title="Network with Line Capacities Emphasized (Log Scale)",
+         color_geomap=True,
+         geomap=True,
+     )
+     
+     # Add a custom colorbar for line capacities
+     import matplotlib as mpl
+     
+     # Create a dummy mappable for the colorbar
+     norm = mpl.colors.Normalize(vmin=n.lines.s_nom.min(), vmax=n.lines.s_nom.max())
+     sm = plt.cm.ScalarMappable(cmap=plt.cm.Blues, norm=norm)
+     sm.set_array([])
+     
+     # Add colorbar
+     cbar = plt.colorbar(sm, ax=ax, orientation='horizontal', pad=0.05, 
+                         label='Line Capacity (s_nom)')
+     
+     # Add a note about disconnected buses
+     if len(isolated_buses) > 0:
+         ax.text(0.02, 0.02, f"Note: {len(isolated_buses)} isolated buses found", 
+                 transform=ax.transAxes, fontsize=10, 
+                 bbox=dict(facecolor='white', alpha=0.7))
+ else:
+     ax.text(0.5, 0.5, "No lines in the network", 
+             transform=ax.transAxes, fontsize=14, ha='center')
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

## Todo List

- [x] Analyze network connectivity to identify disconnected buses
- [x] Visualize network with connected components highlighted
- [x] Check line parameters that might cause visualization issues
- [x] Create enhanced visualization with line capacities emphasized

---

There are several reasons why some buses appear disconnected in your network visualization:

1. **Actual Network Topology**: 
   - Your network may have multiple isolated components that aren't electrically connected to each other
   - Some buses might be truly isolated with no lines connecting them
   - This is common in power system models representing islands or isolated microgrids

2. **Line Capacity Issues**:
   - Lines with very small capacities (s_nom) may appear as thin or invisible lines
   - Zero-capacity lines won't be visible in the visualization
   - Lines that are switched off (status=0) won't show connections

3. **Visualization Scaling**:
   - The default line width scaling might not make all connections visible
   - Very large differences between line capacities can make smaller lines appear invisible

I've added several diagnostic cells to help you understand and address this issue:

1. **Network Connectivity Analysis** (Cell 6):
   - Counts the number of connected components in your network
   - Identifies completely isolated buses
   - Shows how many separate "islands" exist in your network

2. **Connected Components Visualization** (Cell 7):
   - Colors buses by their connected component
   - Makes it easy to see which buses are part of the same electrical island
   - Highlights isolated buses in black

3. **Line Parameter Analysis** (Cell 8):
   - Checks for zero or very low capacity lines
   - Identifies lines that might be switched off
   - Provides statistics on line capacities

4. **Enhanced Line Capacity Visualization** (Cell 9):
   - Uses logarithmic scaling to better show line connections
   - Adds a colorbar to indicate line capacities
   - Makes even small-capacity lines visible

Run these cells to better understand your network's topology and why some buses appear disconnected. If the disconnected buses represent a modeling error, you may need to add missing transmission lines or adjust line parameters in your PyPSA network.

---

_**User**_

rather than doing thickness to represent different nominal capacities, please rather do labels for each s_nom

---

_**Assistant**_

I'll create a new visualization that uses labels to show line capacities instead of varying line thickness. Let me add a cell for this:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 49, lines removed: 1

```diff
@@ -1,1 +1,49 @@
- 
+ # Visualize network with capacity labels instead of line thickness
+ fig, ax = plt.subplots(figsize=(14, 10), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with uniform line thickness
+ n.plot(
+     ax=ax,
+     bus_sizes=0.5,
+     bus_colors='red',
+     line_widths=1.0,  # Uniform line width
+     line_colors='blue',
+     title="Network with Line Capacity Labels",
+     color_geomap=True,
+     geomap=True,
+ )
+ 
+ # Add capacity labels to each line
+ if not n.lines.empty:
+     # Format capacity values for display (in MW)
+     for line in n.lines.index:
+         bus0 = n.lines.at[line, 'bus0']
+         bus1 = n.lines.at[line, 'bus1']
+         
+         # Get bus coordinates
+         x0, y0 = n.buses.at[bus0, 'x'], n.buses.at[bus0, 'y']
+         x1, y1 = n.buses.at[bus1, 'x'], n.buses.at[bus1, 'y']
+         
+         # Calculate midpoint for label placement
+         mid_x = (x0 + x1) / 2
+         mid_y = (y0 + y1) / 2
+         
+         # Format capacity value (rounded to nearest integer MW)
+         capacity = int(round(n.lines.at[line, 's_nom']))
+         
+         # Add label with capacity value
+         ax.text(mid_x, mid_y, f"{capacity} MW", 
+                 fontsize=8, 
+                 bbox=dict(facecolor='white', alpha=0.7, edgecolor='none', pad=1),
+                 ha='center', va='center',
+                 zorder=5)  # Higher zorder to ensure labels are on top
+ 
+ # Add a note about disconnected buses
+ if 'isolated_buses' in locals() and len(isolated_buses) > 0:
+     ax.text(0.02, 0.02, f"Note: {len(isolated_buses)} isolated buses found", 
+             transform=ax.transAxes, fontsize=10, 
+             bbox=dict(facecolor='white', alpha=0.7))
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

This visualization might get cluttered if there are many lines. Let's add another cell with an improved version that only shows labels for lines above a certain capacity threshold:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 77, lines removed: 1

```diff
@@ -1,1 +1,77 @@
- 
+ # Visualize network with capacity labels (improved version with threshold)
+ fig, ax = plt.subplots(figsize=(14, 10), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with uniform line thickness but color by capacity
+ if not n.lines.empty:
+     import numpy as np
+     
+     # Create a colormap for line capacities
+     import matplotlib.cm as cm
+     from matplotlib.colors import Normalize
+     
+     # Create a colormap
+     cmap = cm.get_cmap('viridis')
+     norm = Normalize(vmin=n.lines.s_nom.min(), vmax=n.lines.s_nom.max())
+     
+     # Create a dictionary of line colors based on capacity
+     line_colors = {line: cmap(norm(capacity)) for line, capacity in n.lines.s_nom.items()}
+     
+     # Plot with uniform thickness but colors based on capacity
+     n.plot(
+         ax=ax,
+         bus_sizes=0.5,
+         bus_colors='red',
+         line_widths=1.5,  # Uniform line width
+         line_colors=line_colors,  # Colors based on capacity
+         title="Network with Line Capacity Labels (Threshold Applied)",
+         color_geomap=True,
+         geomap=True,
+     )
+     
+     # Calculate threshold for showing labels (e.g., top 30% of lines by capacity)
+     capacity_threshold = np.percentile(n.lines.s_nom, 70)  # Only show labels for top 30%
+     
+     # Add capacity labels to lines above threshold
+     for line in n.lines.index:
+         capacity = n.lines.at[line, 's_nom']
+         
+         # Only label lines above the threshold
+         if capacity >= capacity_threshold:
+             bus0 = n.lines.at[line, 'bus0']
+             bus1 = n.lines.at[line, 'bus1']
+             
+             # Get bus coordinates
+             x0, y0 = n.buses.at[bus0, 'x'], n.buses.at[bus0, 'y']
+             x1, y1 = n.buses.at[bus1, 'x'], n.buses.at[bus1, 'y']
+             
+             # Calculate midpoint for label placement
+             mid_x = (x0 + x1) / 2
+             mid_y = (y0 + y1) / 2
+             
+             # Format capacity value (rounded to nearest integer MW)
+             capacity_int = int(round(capacity))
+             
+             # Add label with capacity value
+             ax.text(mid_x, mid_y, f"{capacity_int} MW", 
+                     fontsize=8, 
+                     bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=1),
+                     ha='center', va='center',
+                     zorder=5)  # Higher zorder to ensure labels are on top
+     
+     # Add colorbar
+     sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
+     sm.set_array([])
+     cbar = plt.colorbar(sm, ax=ax, orientation='horizontal', pad=0.05, 
+                      label='Line Capacity (s_nom) in MW')
+     
+     # Add note about the threshold
+     ax.text(0.02, 0.06, f"Note: Labels shown only for lines with capacity ≥ {int(round(capacity_threshold))} MW", 
+             transform=ax.transAxes, fontsize=10, 
+             bbox=dict(facecolor='white', alpha=0.7))
+ else:
+     ax.text(0.5, 0.5, "No lines in the network", 
+             transform=ax.transAxes, fontsize=14, ha='center')
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

Let's add one more cell that allows you to customize the visualization by setting your own threshold for showing labels:

---

Cannot create a new cell at index 12. Notebook has 10 cells. Use index from 0 to 10, inclusive

---

Let me check how many cells are in the notebook:

---

Read file: undefined

---

Let me try adding the customizable function at the correct index:

---

Cannot create a new cell at index 10. Notebook has 8 cells. Use index from 0 to 8, inclusive

---

Let me try again with the correct index:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 120, lines removed: 1

```diff
@@ -1,1 +1,120 @@
- 
+ # Customizable visualization with capacity labels
+ def plot_network_with_capacity_labels(network, capacity_threshold=None, percentile_threshold=None, 
+                                       figsize=(14, 10), show_all_labels=False):
+     """
+     Plot network with capacity labels.
+     
+     Parameters:
+     -----------
+     network : pypsa.Network
+         The PyPSA network to plot
+     capacity_threshold : float, optional
+         Minimum capacity (in MW) to show labels for
+     percentile_threshold : float, optional
+         Percentile threshold (0-100) to show labels for (e.g., 70 for top 30%)
+     figsize : tuple, optional
+         Figure size
+     show_all_labels : bool, optional
+         If True, show labels for all lines regardless of capacity
+     """
+     import numpy as np
+     import matplotlib.pyplot as plt
+     import matplotlib.cm as cm
+     from matplotlib.colors import Normalize
+     import cartopy.crs as ccrs
+     
+     fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": ccrs.PlateCarree()})
+     
+     if not network.lines.empty:
+         # Create a colormap
+         cmap = cm.get_cmap('viridis')
+         norm = Normalize(vmin=network.lines.s_nom.min(), vmax=network.lines.s_nom.max())
+         
+         # Create a dictionary of line colors based on capacity
+         line_colors = {line: cmap(norm(capacity)) for line, capacity in network.lines.s_nom.items()}
+         
+         # Plot with uniform thickness but colors based on capacity
+         network.plot(
+             ax=ax,
+             bus_sizes=0.5,
+             bus_colors='red',
+             line_widths=1.5,  # Uniform line width
+             line_colors=line_colors,  # Colors based on capacity
+             title="Network with Line Capacity Labels",
+             color_geomap=True,
+             geomap=True,
+         )
+         
+         # Determine threshold for showing labels
+         threshold_note = ""
+         if show_all_labels:
+             # Show all labels
+             lines_to_label = network.lines.index
+             threshold_note = "All lines labeled"
+         elif capacity_threshold is not None:
+             # Use specified capacity threshold
+             lines_to_label = network.lines[network.lines.s_nom >= capacity_threshold].index
+             threshold_note = f"Labels shown for lines with capacity ≥ {capacity_threshold} MW"
+         elif percentile_threshold is not None:
+             # Use percentile threshold
+             threshold = np.percentile(network.lines.s_nom, percentile_threshold)
+             lines_to_label = network.lines[network.lines.s_nom >= threshold].index
+             threshold_note = f"Labels shown for lines with capacity ≥ {int(round(threshold))} MW (top {100-percentile_threshold}%)"
+         else:
+             # Default: show top 30%
+             threshold = np.percentile(network.lines.s_nom, 70)
+             lines_to_label = network.lines[network.lines.s_nom >= threshold].index
+             threshold_note = f"Labels shown for lines with capacity ≥ {int(round(threshold))} MW (top 30%)"
+         
+         # Add capacity labels to selected lines
+         for line in lines_to_label:
+             bus0 = network.lines.at[line, 'bus0']
+             bus1 = network.lines.at[line, 'bus1']
+             
+             # Get bus coordinates
+             x0, y0 = network.buses.at[bus0, 'x'], network.buses.at[bus0, 'y']
+             x1, y1 = network.buses.at[bus1, 'x'], network.buses.at[bus1, 'y']
+             
+             # Calculate midpoint for label placement
+             mid_x = (x0 + x1) / 2
+             mid_y = (y0 + y1) / 2
+             
+             # Format capacity value (rounded to nearest integer MW)
+             capacity = int(round(network.lines.at[line, 's_nom']))
+             
+             # Add label with capacity value
+             ax.text(mid_x, mid_y, f"{capacity} MW", 
+                     fontsize=8, 
+                     bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=1),
+                     ha='center', va='center',
+                     zorder=5)
+         
+         # Add colorbar
+         sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
+         sm.set_array([])
+         cbar = plt.colorbar(sm, ax=ax, orientation='horizontal', pad=0.05, 
+                          label='Line Capacity (s_nom) in MW')
+         
+         # Add note about the threshold
+         ax.text(0.02, 0.06, f"Note: {threshold_note}", 
+                 transform=ax.transAxes, fontsize=10, 
+                 bbox=dict(facecolor='white', alpha=0.7))
+     else:
+         ax.text(0.5, 0.5, "No lines in the network", 
+                 transform=ax.transAxes, fontsize=14, ha='center')
+     
+     plt.tight_layout()
+     return fig, ax
+ 
+ # Example usage: Show labels for lines with capacity >= 100 MW
+ plot_network_with_capacity_labels(n, capacity_threshold=100)
+ plt.show()
+ 
+ # Example usage: Show labels for top 20% of lines by capacity
+ # plot_network_with_capacity_labels(n, percentile_threshold=80)
+ # plt.show()
+ 
+ # Example usage: Show labels for all lines (may be cluttered)
+ # plot_network_with_capacity_labels(n, show_all_labels=True)
+ # plt.show()
+ 
```

</details>

---

<no message>

---

## Todo List

- [x] Create visualization with capacity labels instead of line thickness
- [x] Implement improved visualization with threshold for capacity labels
- [x] Create customizable function for capacity label visualization

---

I've created visualizations that use labels to show line capacities instead of varying line thickness as you requested. The notebook now includes:

1. A basic visualization with capacity labels for each line
2. A reusable function `plot_network_with_capacity_labels()` that gives you full control over how the labels are displayed

The function allows you to:

- Show labels for all lines (`show_all_labels=True`)
- Show labels only for lines above a specific capacity (`capacity_threshold=100`)
- Show labels only for the top X% of lines by capacity (`percentile_threshold=80`)

The visualization uses uniform line thickness (1.5) but colors the lines based on their capacity using a colormap, making it easy to see which lines have higher capacities. Each labeled line shows its capacity in MW directly on the map.

This approach makes it much easier to see the exact capacity values compared to the previous visualizations that used line thickness. You can adjust the threshold parameters to control how many labels appear on the map, which is helpful if your network has many lines and showing all labels would be too cluttered.

---

_**User**_

modify this carrier plotting cell so that you dont plot buses based on size but rather plot them all the same and label with top 3 carriers and their stats

---

_**Assistant**_

I'll create a new notebook with a cell that plots buses with uniform sizes and labels showing the top 3 carriers and their stats.

---



---

I'll recreate the notebook using the edit_notebook tool:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 10, lines removed: 1

```diff
@@ -1,1 +1,10 @@
- 
+ import pypsa
+ import matplotlib.pyplot as plt
+ import cartopy.crs as ccrs
+ import pandas as pd
+ import numpy as np
+ 
+ # Load network
+ network_file="/Users/antoniagrindrod/Documents/pypsa-earth_project/pypsa-earth-RL/networks/elec_s_5_ec_lcopt_3h.nc"
+ n = pypsa.Network(network_file)
+ 
```

</details>

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 53, lines removed: 1

```diff
@@ -1,1 +1,53 @@
- 
+ # Plot network with uniform bus sizes and labels for top 3 carriers
+ fig, ax = plt.subplots(figsize=(14, 10), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with uniform bus sizes
+ n.plot(
+     ax=ax,
+     bus_sizes=0.5,  # Uniform size for all buses
+     bus_colors='darkblue',  # Uniform color for all buses
+     line_widths=1.0,  # Uniform line width
+     line_colors='gray',
+     title="Network with Bus Labels for Top 3 Carriers",
+     color_geomap=True,
+     geomap=True,
+ )
+ 
+ # Calculate generation stats by bus and carrier
+ if not n.generators.empty:
+     # Group generators by bus and carrier, and sum their capacities
+     bus_carrier_stats = n.generators.groupby(['bus', 'carrier'])['p_nom'].sum().reset_index()
+     
+     # Get top 3 carriers for each bus
+     bus_stats = {}
+     for bus in n.buses.index:
+         # Get generators at this bus
+         bus_data = bus_carrier_stats[bus_carrier_stats.bus == bus]
+         if not bus_data.empty:
+             # Sort by capacity (descending) and take top 3
+             top_carriers = bus_data.sort_values('p_nom', ascending=False).head(3)
+             bus_stats[bus] = top_carriers
+     
+     # Add labels to buses
+     for bus, top_carriers in bus_stats.items():
+         x, y = n.buses.at[bus, 'x'], n.buses.at[bus, 'y']
+         
+         # Format label text with top carriers and their capacities
+         label_lines = [f"{bus}:"]
+         for _, row in top_carriers.iterrows():
+             carrier = row['carrier']
+             capacity = int(round(row['p_nom']))
+             label_lines.append(f"{carrier}: {capacity} MW")
+         
+         label_text = '\n'.join(label_lines)
+         
+         # Add label with capacity value
+         ax.text(x, y, label_text, 
+                 fontsize=7, 
+                 bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=1),
+                 ha='center', va='center',
+                 zorder=5)  # Higher zorder to ensure labels are on top
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

<no message>

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 60, lines removed: 1

```diff
@@ -1,1 +1,60 @@
- 
+ # Improved version with better label positioning and formatting
+ fig, ax = plt.subplots(figsize=(14, 10), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with uniform bus sizes
+ n.plot(
+     ax=ax,
+     bus_sizes=0.5,  # Uniform size for all buses
+     bus_colors='darkblue',  # Uniform color for all buses
+     line_widths=1.0,  # Uniform line width
+     line_colors='gray',
+     title="Network with Bus Labels for Top 3 Carriers (Improved)",
+     color_geomap=True,
+     geomap=True,
+ )
+ 
+ # Calculate generation stats by bus and carrier
+ if not n.generators.empty:
+     # Group generators by bus and carrier, and sum their capacities
+     bus_carrier_stats = n.generators.groupby(['bus', 'carrier'])['p_nom'].sum().reset_index()
+     
+     # Calculate total capacity per bus for percentage calculation
+     bus_total_capacity = bus_carrier_stats.groupby('bus')['p_nom'].sum()
+     
+     # Get top 3 carriers for each bus
+     bus_stats = {}
+     for bus in n.buses.index:
+         # Get generators at this bus
+         bus_data = bus_carrier_stats[bus_carrier_stats.bus == bus]
+         if not bus_data.empty:
+             # Sort by capacity (descending) and take top 3
+             top_carriers = bus_data.sort_values('p_nom', ascending=False).head(3)
+             bus_stats[bus] = top_carriers
+     
+     # Add labels to buses with offset to avoid overlap with bus markers
+     for bus, top_carriers in bus_stats.items():
+         x, y = n.buses.at[bus, 'x'], n.buses.at[bus, 'y']
+         
+         # Get total capacity for this bus
+         total_capacity = bus_total_capacity.get(bus, 0)
+         
+         # Format label text with top carriers, their capacities and percentages
+         label_lines = [f"{bus}:"]
+         for _, row in top_carriers.iterrows():
+             carrier = row['carrier']
+             capacity = int(round(row['p_nom']))
+             percentage = (row['p_nom'] / total_capacity) * 100 if total_capacity > 0 else 0
+             label_lines.append(f"{carrier}: {capacity} MW ({percentage:.1f}%)")
+         
+         label_text = '\n'.join(label_lines)
+         
+         # Add label with slight offset to avoid overlap with bus marker
+         ax.text(x + 0.1, y + 0.1, label_text, 
+                 fontsize=7, 
+                 bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray', pad=1),
+                 ha='left', va='bottom',
+                 zorder=5)  # Higher zorder to ensure labels are on top
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

<no message>

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 94, lines removed: 1

```diff
@@ -1,1 +1,94 @@
- 
+ # Customizable function for bus labels with top carriers
+ def plot_network_with_bus_labels(network, num_top_carriers=3, figsize=(14, 10), 
+                                show_percentages=True, label_offset=(0.1, 0.1)):
+     """
+     Plot network with uniform bus sizes and labels showing top carriers.
+     
+     Parameters:
+     -----------
+     network : pypsa.Network
+         The PyPSA network to plot
+     num_top_carriers : int, optional
+         Number of top carriers to show for each bus (default: 3)
+     figsize : tuple, optional
+         Figure size (default: (14, 10))
+     show_percentages : bool, optional
+         Whether to show percentages in labels (default: True)
+     label_offset : tuple, optional
+         (x, y) offset for label positioning (default: (0.1, 0.1))
+     """
+     import matplotlib.pyplot as plt
+     import cartopy.crs as ccrs
+     
+     fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": ccrs.PlateCarree()})
+     
+     # Plot network with uniform bus sizes
+     network.plot(
+         ax=ax,
+         bus_sizes=0.5,  # Uniform size for all buses
+         bus_colors='darkblue',  # Uniform color for all buses
+         line_widths=1.0,  # Uniform line width
+         line_colors='gray',
+         title=f"Network with Bus Labels for Top {num_top_carriers} Carriers",
+         color_geomap=True,
+         geomap=True,
+     )
+     
+     # Calculate generation stats by bus and carrier
+     if not network.generators.empty:
+         # Group generators by bus and carrier, and sum their capacities
+         bus_carrier_stats = network.generators.groupby(['bus', 'carrier'])['p_nom'].sum().reset_index()
+         
+         # Calculate total capacity per bus for percentage calculation
+         bus_total_capacity = bus_carrier_stats.groupby('bus')['p_nom'].sum()
+         
+         # Get top carriers for each bus
+         bus_stats = {}
+         for bus in network.buses.index:
+             # Get generators at this bus
+             bus_data = bus_carrier_stats[bus_carrier_stats.bus == bus]
+             if not bus_data.empty:
+                 # Sort by capacity (descending) and take top N
+                 top_carriers = bus_data.sort_values('p_nom', ascending=False).head(num_top_carriers)
+                 bus_stats[bus] = top_carriers
+         
+         # Add labels to buses with offset to avoid overlap with bus markers
+         for bus, top_carriers in bus_stats.items():
+             x, y = network.buses.at[bus, 'x'], network.buses.at[bus, 'y']
+             
+             # Get total capacity for this bus
+             total_capacity = bus_total_capacity.get(bus, 0)
+             
+             # Format label text with top carriers, their capacities and percentages
+             label_lines = [f"{bus}:"]
+             for _, row in top_carriers.iterrows():
+                 carrier = row['carrier']
+                 capacity = int(round(row['p_nom']))
+                 
+                 if show_percentages and total_capacity > 0:
+                     percentage = (row['p_nom'] / total_capacity) * 100
+                     label_lines.append(f"{carrier}: {capacity} MW ({percentage:.1f}%)")
+                 else:
+                     label_lines.append(f"{carrier}: {capacity} MW")
+             
+             label_text = '\n'.join(label_lines)
+             
+             # Add label with offset to avoid overlap with bus marker
+             ax.text(x + label_offset[0], y + label_offset[1], label_text, 
+                     fontsize=7, 
+                     bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray', pad=1),
+                     ha='left', va='bottom',
+                     zorder=5)  # Higher zorder to ensure labels are on top
+     
+     plt.tight_layout()
+     return fig, ax
+ 
+ # Example usage: Show top 3 carriers with percentages
+ plot_network_with_bus_labels(n, num_top_carriers=3, show_percentages=True)
+ plt.show()
+ 
+ # Uncomment to try different options:
+ # Show top 2 carriers without percentages
+ # plot_network_with_bus_labels(n, num_top_carriers=2, show_percentages=False)
+ # plt.show()
+ 
```

</details>

---

<no message>

---

## Todo List

- [x] Create visualization with uniform bus sizes and top carrier labels
- [x] Add percentage information to carrier statistics
- [x] Create customizable function for bus labels with carrier stats

---

I've created a new notebook with visualizations that plot buses with uniform sizes and label them with their top carriers and statistics as requested. The notebook includes:

1. A basic visualization showing uniform-sized buses with labels for the top 3 carriers at each bus and their capacities in MW.

2. An improved version that:
   - Shows percentages for each carrier (what percentage of the bus's total capacity it represents)
   - Uses an offset for labels to avoid overlap with bus markers
   - Has better formatting with borders around labels

3. A customizable function `plot_network_with_bus_labels()` that lets you:
   - Choose how many top carriers to show (default: 3)
   - Toggle whether to show percentages
   - Adjust label positioning
   - Customize figure size

This approach gives you a clearer view of the generation mix at each bus location rather than trying to represent it through varying bus sizes. The labels show both the absolute capacity values (in MW) and the relative importance of each carrier (as percentages).

You can run any of these cells to visualize your network, or use the customizable function with different parameters to adjust the visualization to your needs.

---

_**User**_

please make a new cell that does the carriers and the nominal line capacity. You don't need to plot the carrier information in the middle of the bus you can plot if off to the side. please make the text bigger than before

---

_**Assistant**_

I'll create a new cell that combines both carrier information and line capacities with larger text and improved positioning.

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 97, lines removed: 1

```diff
@@ -1,1 +1,97 @@
- 
+ # Combined visualization: Carrier information and line capacities with larger text
+ fig, ax = plt.subplots(figsize=(16, 12), subplot_kw={"projection": ccrs.PlateCarree()})
+ 
+ # Plot network with uniform bus sizes
+ n.plot(
+     ax=ax,
+     bus_sizes=0.7,  # Slightly larger uniform size for all buses
+     bus_colors='darkblue',  # Uniform color for all buses
+     line_widths=1.5,  # Uniform line width
+     line_colors='gray',
+     title="Network with Bus Carrier Info and Line Capacities",
+     color_geomap=True,
+     geomap=True,
+ )
+ 
+ # 1. Add line capacity labels
+ if not n.lines.empty:
+     # Calculate threshold for showing labels (e.g., top 30% of lines by capacity)
+     capacity_threshold = np.percentile(n.lines.s_nom, 70)
+     
+     # Add capacity labels to lines above threshold
+     for line in n.lines.index:
+         capacity = n.lines.at[line, 's_nom']
+         
+         # Only label lines above the threshold
+         if capacity >= capacity_threshold:
+             bus0 = n.lines.at[line, 'bus0']
+             bus1 = n.lines.at[line, 'bus1']
+             
+             # Get bus coordinates
+             x0, y0 = n.buses.at[bus0, 'x'], n.buses.at[bus0, 'y']
+             x1, y1 = n.buses.at[bus1, 'x'], n.buses.at[bus1, 'y']
+             
+             # Calculate midpoint for label placement
+             mid_x = (x0 + x1) / 2
+             mid_y = (y0 + y1) / 2
+             
+             # Format capacity value (rounded to nearest integer MW)
+             capacity_int = int(round(capacity))
+             
+             # Add label with capacity value
+             ax.text(mid_x, mid_y, f"{capacity_int} MW", 
+                     fontsize=10,  # Larger text
+                     bbox=dict(facecolor='white', alpha=0.8, edgecolor='blue', pad=2),
+                     ha='center', va='center',
+                     zorder=5)
+ 
+ # 2. Add carrier information with offset positioning and larger text
+ if not n.generators.empty:
+     # Group generators by bus and carrier, and sum their capacities
+     bus_carrier_stats = n.generators.groupby(['bus', 'carrier'])['p_nom'].sum().reset_index()
+     
+     # Calculate total capacity per bus for percentage calculation
+     bus_total_capacity = bus_carrier_stats.groupby('bus')['p_nom'].sum()
+     
+     # Get top 3 carriers for each bus
+     bus_stats = {}
+     for bus in n.buses.index:
+         # Get generators at this bus
+         bus_data = bus_carrier_stats[bus_carrier_stats.bus == bus]
+         if not bus_data.empty:
+             # Sort by capacity (descending) and take top 3
+             top_carriers = bus_data.sort_values('p_nom', ascending=False).head(3)
+             bus_stats[bus] = top_carriers
+     
+     # Add labels to buses with offset to avoid overlap
+     for bus, top_carriers in bus_stats.items():
+         x, y = n.buses.at[bus, 'x'], n.buses.at[bus, 'y']
+         
+         # Get total capacity for this bus
+         total_capacity = bus_total_capacity.get(bus, 0)
+         
+         # Format label text with top carriers and their capacities
+         label_lines = [f"{bus}:"]
+         for _, row in top_carriers.iterrows():
+             carrier = row['carrier']
+             capacity = int(round(row['p_nom']))
+             percentage = (row['p_nom'] / total_capacity) * 100 if total_capacity > 0 else 0
+             label_lines.append(f"{carrier}: {capacity} MW ({percentage:.1f}%)")
+         
+         label_text = '\n'.join(label_lines)
+         
+         # Add label with larger offset to the right of the bus marker
+         ax.text(x + 0.3, y, label_text, 
+                 fontsize=9,  # Larger text
+                 bbox=dict(facecolor='white', alpha=0.9, edgecolor='darkgreen', pad=3),
+                 ha='left', va='center',
+                 zorder=6)  # Higher zorder to ensure labels are on top
+ 
+ # Add note about the threshold for line capacities
+ ax.text(0.02, 0.05, f"Note: Line labels shown only for capacities ≥ {int(round(capacity_threshold))} MW", 
+         transform=ax.transAxes, fontsize=12, 
+         bbox=dict(facecolor='white', alpha=0.7))
+ 
+ plt.tight_layout()
+ plt.show()
+ 
```

</details>

---

Let me create one more cell with a customizable function that combines both features:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 140, lines removed: 1

```diff
@@ -1,1 +1,140 @@
- 
+ # Customizable function for combined visualization
+ def plot_network_with_carriers_and_capacities(
+     network, 
+     num_top_carriers=3, 
+     line_capacity_percentile=70,
+     figsize=(16, 12),
+     carrier_label_offset=0.3,
+     bus_text_size=9,
+     line_text_size=10
+ ):
+     """
+     Plot network with both carrier information and line capacities.
+     
+     Parameters:
+     -----------
+     network : pypsa.Network
+         The PyPSA network to plot
+     num_top_carriers : int, optional
+         Number of top carriers to show for each bus (default: 3)
+     line_capacity_percentile : float, optional
+         Percentile threshold for showing line capacity labels (default: 70)
+     figsize : tuple, optional
+         Figure size (default: (16, 12))
+     carrier_label_offset : float, optional
+         Horizontal offset for carrier labels (default: 0.3)
+     bus_text_size : int, optional
+         Font size for bus carrier labels (default: 9)
+     line_text_size : int, optional
+         Font size for line capacity labels (default: 10)
+     """
+     import matplotlib.pyplot as plt
+     import cartopy.crs as ccrs
+     import numpy as np
+     
+     fig, ax = plt.subplots(figsize=figsize, subplot_kw={"projection": ccrs.PlateCarree()})
+     
+     # Plot network with uniform bus sizes
+     network.plot(
+         ax=ax,
+         bus_sizes=0.7,
+         bus_colors='darkblue',
+         line_widths=1.5,
+         line_colors='gray',
+         title="Network with Bus Carrier Info and Line Capacities",
+         color_geomap=True,
+         geomap=True,
+     )
+     
+     # 1. Add line capacity labels
+     if not network.lines.empty:
+         # Calculate threshold for showing labels
+         capacity_threshold = np.percentile(network.lines.s_nom, line_capacity_percentile)
+         
+         # Add capacity labels to lines above threshold
+         for line in network.lines.index:
+             capacity = network.lines.at[line, 's_nom']
+             
+             # Only label lines above the threshold
+             if capacity >= capacity_threshold:
+                 bus0 = network.lines.at[line, 'bus0']
+                 bus1 = network.lines.at[line, 'bus1']
+                 
+                 # Get bus coordinates
+                 x0, y0 = network.buses.at[bus0, 'x'], network.buses.at[bus0, 'y']
+                 x1, y1 = network.buses.at[bus1, 'x'], network.buses.at[bus1, 'y']
+                 
+                 # Calculate midpoint for label placement
+                 mid_x = (x0 + x1) / 2
+                 mid_y = (y0 + y1) / 2
+                 
+                 # Format capacity value (rounded to nearest integer MW)
+                 capacity_int = int(round(capacity))
+                 
+                 # Add label with capacity value
+                 ax.text(mid_x, mid_y, f"{capacity_int} MW", 
+                         fontsize=line_text_size,
+                         bbox=dict(facecolor='white', alpha=0.8, edgecolor='blue', pad=2),
+                         ha='center', va='center',
+                         zorder=5)
+     
+     # 2. Add carrier information with offset positioning
+     if not network.generators.empty:
+         # Group generators by bus and carrier, and sum their capacities
+         bus_carrier_stats = network.generators.groupby(['bus', 'carrier'])['p_nom'].sum().reset_index()
+         
+         # Calculate total capacity per bus for percentage calculation
+         bus_total_capacity = bus_carrier_stats.groupby('bus')['p_nom'].sum()
+         
+         # Get top carriers for each bus
+         bus_stats = {}
+         for bus in network.buses.index:
+             # Get generators at this bus
+             bus_data = bus_carrier_stats[bus_carrier_stats.bus == bus]
+             if not bus_data.empty:
+                 # Sort by capacity (descending) and take top N
+                 top_carriers = bus_data.sort_values('p_nom', ascending=False).head(num_top_carriers)
+                 bus_stats[bus] = top_carriers
+         
+         # Add labels to buses with offset to avoid overlap
+         for bus, top_carriers in bus_stats.items():
+             x, y = network.buses.at[bus, 'x'], network.buses.at[bus, 'y']
+             
+             # Get total capacity for this bus
+             total_capacity = bus_total_capacity.get(bus, 0)
+             
+             # Format label text with top carriers and their capacities
+             label_lines = [f"{bus}:"]
+             for _, row in top_carriers.iterrows():
+                 carrier = row['carrier']
+                 capacity = int(round(row['p_nom']))
+                 percentage = (row['p_nom'] / total_capacity) * 100 if total_capacity > 0 else 0
+                 label_lines.append(f"{carrier}: {capacity} MW ({percentage:.1f}%)")
+             
+             label_text = '\n'.join(label_lines)
+             
+             # Add label with offset to the right of the bus marker
+             ax.text(x + carrier_label_offset, y, label_text, 
+                     fontsize=bus_text_size,
+                     bbox=dict(facecolor='white', alpha=0.9, edgecolor='darkgreen', pad=3),
+                     ha='left', va='center',
+                     zorder=6)
+     
+     # Add note about the threshold for line capacities
+     ax.text(0.02, 0.05, f"Note: Line labels shown only for capacities ≥ {int(round(capacity_threshold))} MW", 
+             transform=ax.transAxes, fontsize=12, 
+             bbox=dict(facecolor='white', alpha=0.7))
+     
+     plt.tight_layout()
+     return fig, ax
+ 
+ # Example usage with default parameters
+ plot_network_with_carriers_and_capacities(n)
+ plt.show()
+ 
+ # Uncomment to try different options:
+ # Show top 2 carriers with larger text and higher threshold for line capacities
+ # plot_network_with_carriers_and_capacities(n, num_top_carriers=2, line_capacity_percentile=80, 
+ #                                          bus_text_size=11, line_text_size=12)
+ # plt.show()
+ 
```

</details>

---

<no message>

---

## Todo List

- [x] Create combined visualization with carrier info and line capacities
- [x] Implement larger text and offset positioning for carrier labels
- [x] Create customizable function for combined visualization

---

I've created two new cells that combine carrier information and line capacity labels with larger text as requested:

1. **First Cell (Basic Combined Visualization):**
   - Shows uniform-sized buses with carrier information positioned to the side
   - Displays line capacity labels for major transmission lines
   - Uses larger text for both bus carrier info (fontsize=9) and line capacities (fontsize=10)
   - Places carrier information with an offset (x + 0.3) to avoid overlap with bus markers
   - Uses colored borders to distinguish between carrier info (green) and line capacity (blue)

2. **Second Cell (Customizable Function):**
   - Provides a flexible function `plot_network_with_carriers_and_capacities()` that lets you adjust:
     - Number of top carriers to display
     - Text size for both carrier and line capacity labels
     - Offset positioning for carrier labels
     - Threshold for showing line capacity labels
     - Figure size

The visualizations now:
- Use uniform bus sizes rather than varying sizes
- Position carrier information to the side of each bus for better readability
- Show line capacities directly on the lines
- Use larger text as requested
- Have clear visual distinction between different types of information

You can run either cell to see the visualization, or use the customizable function with different parameters to adjust the display to your preferences.

---

_**User**_

please change your last cell so you label all the line capcities, not just those above a certain threshold

---

_**Assistant**_

I'll modify the last cell to label all line capacities without applying any threshold.

---



---

_**User**_

for each bus, please plot the total demand (sum of power at each load) as a function of time

---

_**Assistant**_

I'll create a new cell to visualize the total demand (load) at each bus over time.

---

Read file: undefined

---

Let me check the structure of the network to understand how to access the load data:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 21, lines removed: 1

```diff
@@ -1,1 +1,21 @@
- 
+ # Check the structure of loads in the network
+ print("Loads in the network:")
+ if not n.loads.empty:
+     print(f"Number of loads: {len(n.loads)}")
+     print("\nLoad columns:")
+     print(n.loads.columns.tolist())
+     print("\nFirst few loads:")
+     print(n.loads.head())
+     
+     # Check if time-varying data is available
+     if hasattr(n, 'loads_t') and hasattr(n.loads_t, 'p_set'):
+         print("\nTime-varying load data available:")
+         print(f"Time periods: {len(n.loads_t.p_set)}")
+         print(f"Time index: {n.loads_t.p_set.index[:5]}...")
+         print("\nSample of load time series data:")
+         print(n.loads_t.p_set.iloc[:5, :3])  # First 5 time steps, first 3 loads
+     else:
+         print("\nNo time-varying load data found in n.loads_t.p_set")
+ else:
+     print("No loads found in the network")
+ 
```

</details>

---

Now let's create a visualization of the load time series for each bus:

---

Cannot create a new cell at index 7. Notebook has 6 cells. Use index from 0 to 6, inclusive

---

Let me try with the correct index:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 67, lines removed: 1

```diff
@@ -1,1 +1,67 @@
- 
+ # Plot total demand (load) for each bus over time
+ if not n.loads.empty and hasattr(n, 'loads_t') and hasattr(n.loads_t, 'p_set'):
+     # Group loads by bus and sum them
+     bus_loads = {}
+     
+     # Get unique buses with loads
+     load_buses = n.loads.bus.unique()
+     print(f"Number of buses with loads: {len(load_buses)}")
+     
+     # For each bus, sum up all loads connected to it at each time step
+     for bus in load_buses:
+         # Get indices of loads connected to this bus
+         bus_load_indices = n.loads[n.loads.bus == bus].index
+         
+         # Sum up the load time series for this bus
+         if len(bus_load_indices) > 0:
+             bus_loads[bus] = n.loads_t.p_set[bus_load_indices].sum(axis=1)
+     
+     # Create a DataFrame with all bus loads
+     bus_loads_df = pd.DataFrame(bus_loads)
+     
+     # Plot the load time series for each bus
+     plt.figure(figsize=(15, 8))
+     
+     # If there are many buses, limit the number shown or use a different visualization approach
+     if len(bus_loads_df.columns) > 10:
+         # Option 1: Plot a subset of buses (e.g., top 10 by average load)
+         top_buses = bus_loads_df.mean().sort_values(ascending=False).head(10).index
+         bus_loads_df[top_buses].plot(ax=plt.gca())
+         plt.title('Total Demand Over Time - Top 10 Buses by Average Load')
+     else:
+         # Plot all buses if there aren't too many
+         bus_loads_df.plot(ax=plt.gca())
+         plt.title('Total Demand Over Time - All Buses with Loads')
+     
+     plt.xlabel('Time')
+     plt.ylabel('Load (MW)')
+     plt.grid(True)
+     plt.legend(title='Bus', bbox_to_anchor=(1.05, 1), loc='upper left')
+     plt.tight_layout()
+     plt.show()
+     
+     # Also create a heatmap visualization for all buses
+     plt.figure(figsize=(16, 10))
+     import seaborn as sns
+     
+     # If there are many time steps, sample them for better visualization
+     if len(bus_loads_df) > 50:
+         # Sample every Nth time step
+         sample_step = len(bus_loads_df) // 50 + 1
+         heatmap_data = bus_loads_df.iloc[::sample_step]
+     else:
+         heatmap_data = bus_loads_df
+     
+     # Create heatmap
+     sns.heatmap(heatmap_data.T, cmap='viridis', 
+                 xticklabels=20 if len(heatmap_data) > 20 else True,
+                 yticklabels=True,
+                 cbar_kws={'label': 'Load (MW)'})
+     plt.title('Heatmap of Load Over Time for All Buses')
+     plt.xlabel('Time Steps')
+     plt.ylabel('Bus')
+     plt.tight_layout()
+     plt.show()
+ else:
+     print("Cannot plot load time series: either no loads in the network or no time-varying data available")
+ 
```

</details>

---

Let me add one more cell with a customizable function for plotting load time series:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 99, lines removed: 1

```diff
@@ -1,1 +1,99 @@
- 
+ # Customizable function for plotting bus demand over time
+ def plot_bus_demand_over_time(network, top_n=10, figsize=(15, 8), 
+                              include_heatmap=True, heatmap_figsize=(16, 10)):
+     """
+     Plot the total demand (load) for each bus over time.
+     
+     Parameters:
+     -----------
+     network : pypsa.Network
+         The PyPSA network to plot
+     top_n : int, optional
+         Number of top buses by average load to display in line plot (default: 10)
+     figsize : tuple, optional
+         Figure size for line plot (default: (15, 8))
+     include_heatmap : bool, optional
+         Whether to include a heatmap visualization (default: True)
+     heatmap_figsize : tuple, optional
+         Figure size for heatmap (default: (16, 10))
+     """
+     if not network.loads.empty and hasattr(network, 'loads_t') and hasattr(network.loads_t, 'p_set'):
+         # Group loads by bus and sum them
+         bus_loads = {}
+         
+         # Get unique buses with loads
+         load_buses = network.loads.bus.unique()
+         print(f"Number of buses with loads: {len(load_buses)}")
+         
+         # For each bus, sum up all loads connected to it at each time step
+         for bus in load_buses:
+             # Get indices of loads connected to this bus
+             bus_load_indices = network.loads[network.loads.bus == bus].index
+             
+             # Sum up the load time series for this bus
+             if len(bus_load_indices) > 0:
+                 bus_loads[bus] = network.loads_t.p_set[bus_load_indices].sum(axis=1)
+         
+         # Create a DataFrame with all bus loads
+         bus_loads_df = pd.DataFrame(bus_loads)
+         
+         # 1. Line plot of load time series
+         plt.figure(figsize=figsize)
+         
+         # If there are many buses, limit the number shown
+         if len(bus_loads_df.columns) > top_n:
+             # Plot top N buses by average load
+             top_buses = bus_loads_df.mean().sort_values(ascending=False).head(top_n).index
+             bus_loads_df[top_buses].plot(ax=plt.gca())
+             plt.title(f'Total Demand Over Time - Top {top_n} Buses by Average Load')
+         else:
+             # Plot all buses if there aren't too many
+             bus_loads_df.plot(ax=plt.gca())
+             plt.title('Total Demand Over Time - All Buses with Loads')
+         
+         plt.xlabel('Time')
+         plt.ylabel('Load (MW)')
+         plt.grid(True)
+         plt.legend(title='Bus', bbox_to_anchor=(1.05, 1), loc='upper left')
+         plt.tight_layout()
+         plt.show()
+         
+         # 2. Heatmap visualization (optional)
+         if include_heatmap:
+             plt.figure(figsize=heatmap_figsize)
+             import seaborn as sns
+             
+             # If there are many time steps, sample them for better visualization
+             if len(bus_loads_df) > 50:
+                 # Sample every Nth time step
+                 sample_step = len(bus_loads_df) // 50 + 1
+                 heatmap_data = bus_loads_df.iloc[::sample_step]
+             else:
+                 heatmap_data = bus_loads_df
+             
+             # Create heatmap
+             sns.heatmap(heatmap_data.T, cmap='viridis', 
+                         xticklabels=20 if len(heatmap_data) > 20 else True,
+                         yticklabels=True,
+                         cbar_kws={'label': 'Load (MW)'})
+             plt.title('Heatmap of Load Over Time for All Buses')
+             plt.xlabel('Time Steps')
+             plt.ylabel('Bus')
+             plt.tight_layout()
+             plt.show()
+             
+         # 3. Return the DataFrame for further analysis
+         return bus_loads_df
+     else:
+         print("Cannot plot load time series: either no loads in the network or no time-varying data available")
+         return None
+ 
+ # Example usage
+ bus_demand_df = plot_bus_demand_over_time(n, top_n=10)
+ 
+ # If you want to analyze the data further, you can use the returned DataFrame
+ if bus_demand_df is not None:
+     # Print summary statistics
+     print("\nSummary statistics of bus demand:")
+     print(bus_demand_df.describe().T.sort_values('mean', ascending=False))
+ 
```

</details>

---

<no message>

---

## Todo List

- [x] Create visualization of total demand at each bus over time
- [x] Implement heatmap visualization for all bus demands
- [x] Create customizable function for demand visualization

---

I've added two new cells to your notebook that visualize the total demand (load) at each bus over time:

1. **First Cell**: Basic visualization that:
   - Calculates the total demand at each bus by summing all loads connected to that bus
   - Creates a line plot showing demand over time for each bus (or top 10 buses if there are many)
   - Generates a heatmap visualization showing all buses' demand patterns over time

2. **Second Cell**: A customizable function `plot_bus_demand_over_time()` that provides:
   - Control over how many top buses to display in the line plot
   - Options to include/exclude the heatmap visualization
   - Customizable figure sizes
   - Returns the demand data as a DataFrame for further analysis
   - Prints summary statistics of demand for each bus

These visualizations help you understand:
- How demand varies over time at each bus
- Which buses have the highest average demand
- Patterns in demand across the network
- Temporal correlations between different buses' demand profiles

The heatmap is particularly useful for identifying patterns across all buses simultaneously, while the line plot provides more detailed information about specific high-demand buses.

If the network has many buses, the code automatically selects the top 10 buses by average demand for the line plot to keep the visualization readable, while still showing all buses in the heatmap.

---

_**User**_

can you modify plot_bus_demand_over_time so i can select which months i want to include

---

_**Assistant**_

I'll modify the `plot_bus_demand_over_time` function to allow you to select specific months for the visualization.

---

Cannot access cell at index 7. Notebook has 7 cells. Use index from 0 to 6, inclusive

---

Let me check the current structure of the notebook:

---

Read file: undefined

---

Let me try with the correct index:

---



---

Let me check the current content of the notebook:

---

Read file: undefined

---

Now I'll create a new cell with the modified function that supports month selection:

---

No string to replace was provided.

---

Let me try a different approach:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 23, lines removed: 1

```diff
@@ -1,1 +1,23 @@
- 
+ # Examples of using the function with month selection
+ # Show winter months (June, July, August for Southern Hemisphere)
+ print("Winter months only (June, July, August):")
+ winter_demand = plot_bus_demand_over_time(n, months=[6, 7, 8], top_n=8)
+ 
+ # Show summer months (December, January, February for Southern Hemisphere)
+ print("\nSummer months only (December, January, February):")
+ summer_demand = plot_bus_demand_over_time(n, months=[12, 1, 2], top_n=8)
+ 
+ # Compare winter vs summer average demand
+ if winter_demand is not None and summer_demand is not None:
+     winter_avg = winter_demand.mean()
+     summer_avg = summer_demand.mean()
+     
+     print("\nAverage demand comparison (Winter vs Summer):")
+     comparison = pd.DataFrame({
+         'Winter Avg (MW)': winter_avg,
+         'Summer Avg (MW)': summer_avg,
+         'Difference (MW)': winter_avg - summer_avg,
+         'Percentage Difference (%)': (winter_avg - summer_avg) / summer_avg * 100
+     })
+     print(comparison.sort_values('Winter Avg (MW)', ascending=False))
+ 
```

</details>

---

Now let's create a new cell with the modified function that supports month selection:

---

<details><summary>Edit file: RL/plotSANetwork.ipynb</summary>

undefined

**Chunk 1**
Lines added: 122, lines removed: 1

```diff
@@ -1,1 +1,122 @@
- 
+ # Updated function with month selection capability
+ def plot_bus_demand_over_time_with_months(network, months=None, top_n=10, figsize=(15, 8), 
+                                          include_heatmap=False, heatmap_figsize=(16, 10)):
+     """
+     Plot the total demand (load) for each bus over time with month selection.
+     
+     Parameters:
+     -----------
+     network : pypsa.Network
+         The PyPSA network to plot
+     months : list or None, optional
+         List of months to include (1-12 for Jan-Dec). If None, include all months.
+         Example: [1, 2, 3] for Jan, Feb, Mar only
+     top_n : int, optional
+         Number of top buses by average load to display in line plot (default: 10)
+     figsize : tuple, optional
+         Figure size for line plot (default: (15, 8))
+     include_heatmap : bool, optional
+         Whether to include a heatmap visualization (default: False)
+     heatmap_figsize : tuple, optional
+         Figure size for heatmap (default: (16, 10))
+     """
+     if not network.loads.empty and hasattr(network, 'loads_t') and hasattr(network.loads_t, 'p_set'):
+         # Group loads by bus and sum them
+         bus_loads = {}
+         
+         # Get unique buses with loads
+         load_buses = network.loads.bus.unique()
+         print(f"Number of buses with loads: {len(load_buses)}")
+         
+         # For each bus, sum up all loads connected to it at each time step
+         for bus in load_buses:
+             # Get indices of loads connected to this bus
+             bus_load_indices = network.loads[network.loads.bus == bus].index
+             
+             # Sum up the load time series for this bus
+             if len(bus_load_indices) > 0:
+                 bus_loads[bus] = network.loads_t.p_set[bus_load_indices].sum(axis=1)
+         
+         # Create a DataFrame with all bus loads
+         bus_loads_df = pd.DataFrame(bus_loads)
+         
+         # Check if the time index has datetime information
+         if pd.api.types.is_datetime64_any_dtype(bus_loads_df.index):
+             # Filter by selected months if specified
+             if months is not None:
+                 # Convert months to a list if it's a single integer
+                 if isinstance(months, int):
+                     months = [months]
+                 
+                 # Filter the DataFrame to include only the selected months
+                 month_mask = bus_loads_df.index.month.isin(months)
+                 filtered_df = bus_loads_df.loc[month_mask]
+                 
+                 if filtered_df.empty:
+                     print(f"Warning: No data found for the selected months {months}")
+                     return None
+                 
+                 month_names = [pd.Timestamp(2023, m, 1).strftime('%B') for m in months]
+                 month_str = ", ".join(month_names)
+                 print(f"Showing data for months: {month_str}")
+             else:
+                 filtered_df = bus_loads_df
+                 month_str = "all months"
+         else:
+             # If the index is not datetime, we can't filter by month
+             filtered_df = bus_loads_df
+             if months is not None:
+                 print("Warning: Time index is not datetime format, cannot filter by month")
+             month_str = "all time periods"
+         
+         # 1. Line plot of load time series
+         plt.figure(figsize=figsize)
+         
+         # If there are many buses, limit the number shown
+         if len(filtered_df.columns) > top_n:
+             # Plot top N buses by average load
+             top_buses = filtered_df.mean().sort_values(ascending=False).head(top_n).index
+             filtered_df[top_buses].plot(ax=plt.gca())
+             plt.title(f'Total Demand Over Time - Top {top_n} Buses by Average Load ({month_str})')
+         else:
+             # Plot all buses if there aren't too many
+             filtered_df.plot(ax=plt.gca())
+             plt.title(f'Total Demand Over Time - All Buses with Loads ({month_str})')
+         
+         plt.xlabel('Time')
+         plt.ylabel('Load (MW)')
+         plt.grid(True)
+         plt.legend(title='Bus', bbox_to_anchor=(1.05, 1), loc='upper left')
+         plt.tight_layout()
+         plt.show()
+         
+         # 2. Heatmap visualization (optional)
+         if include_heatmap:
+             plt.figure(figsize=heatmap_figsize)
+             import seaborn as sns
+             
+             # If there are many time steps, sample them for better visualization
+             if len(filtered_df) > 50:
+                 # Sample every Nth time step
+                 sample_step = len(filtered_df) // 50 + 1
+                 heatmap_data = filtered_df.iloc[::sample_step]
+             else:
+                 heatmap_data = filtered_df
+             
+             # Create heatmap
+             sns.heatmap(heatmap_data.T, cmap='viridis', 
+                         xticklabels=20 if len(heatmap_data) > 20 else True,
+                         yticklabels=True,
+                         cbar_kws={'label': 'Load (MW)'})
+             plt.title(f'Heatmap of Load Over Time for All Buses ({month_str})')
+             plt.xlabel('Time Steps')
+             plt.ylabel('Bus')
+             plt.tight_layout()
+             plt.show()
+             
+         # 3. Return the filtered DataFrame for further analysis
+         return filtered_df
+     else:
+         print("Cannot plot load time series: either no loads in the network or no time-varying data available")
+         return None
+ 
```

</details>

---

<no message>

---

## Todo List

- [x] Add month selection capability to bus demand visualization
- [x] Create examples showing seasonal demand patterns
- [x] Implement winter vs summer demand comparison

---

I've added the month selection capability to visualize bus demand over time as requested. Here's what I've implemented:

1. A new function `plot_bus_demand_over_time_with_months()` that:
   - Accepts a `months` parameter to filter data by specific months (1-12 for Jan-Dec)
   - Automatically detects if the time index has datetime information
   - Shows month names in the plot titles
   - Returns the filtered data for further analysis

2. Example usage showing how to:
   - Visualize demand for winter months (June, July, August in Southern Hemisphere)
   - Visualize demand for summer months (December, January, February in Southern Hemisphere)
   - Compare average demand between seasons with percentage differences

The function can handle:
- A single month: `months=6` for June only
- Multiple months: `months=[12, 1, 2]` for summer months
- All months: `months=None` (default)

The seasonal comparison is particularly useful for understanding how demand patterns change throughout the year, which is important for energy planning and grid management.

You can now easily analyze load patterns for any combination of months, making it simple to:
- Compare seasonal variations
- Analyze specific months of interest
- Identify peak demand periods
- Study how demand patterns differ across buses in different seasons

---

